# -*- coding: utf-8 -*-
"""streamlit_app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y_An353f5FCTTqmPL39qaxi81phUo1sZ
"""

import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import mplstereonet

# 1) Function definitions go here
def calculate_planes(points, separation_limit):
    # unchanged from optimized version earlier, except added inline notes
    pts = np.asarray(points, dtype=float)
    n = len(pts)
    # build neighbor sets so we never test triples that already violate separation
    neighbors = [set() for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            if np.linalg.norm(pts[i]-pts[j]) <= separation_limit:
                neighbors[i].add(j)
                neighbors[j].add(i)
    planes = []
    colinear = []
    # --- Iterate only over index triples that respect the separation limit ---
    for i in range(n):
        for j in neighbors[i]:
            if j <= i: continue # ensure j > i
            # Only k that are neighbors of both i and j can form a valid triple
            common = neighbors[i].intersection(neighbors[j])
            for k in common:
                if k <= j: continue # ensure k > j
                p1,p2,p3 = pts[i],pts[j],pts[k]
                # Compute two edge vectors of the triangle
                v1 = p2-p1
                v2 = p3-p1
                # Cross product = normal vector (not yet unit)
                normal = np.cross(v1, v2)
                norm = np.linalg.norm(normal)
                if norm == 0:
                    # Points are colinear or coincident
                    colinear.append((tuple(p1),tuple(p2),tuple(p3)))
                else:
                    # Normalize to unit vector
                    normal /= norm
                    planes.append(tuple(normal))
    return planes, colinear

def extract_strike_dip(planes):
    # plane normal → (strike, dip)
    strikes, dips = [], []
    for nx,ny,nz in planes:
        # flip if down-facing
        if nz < 0:
            nx,ny,nz = -nx,-ny,-nz
        # dip
        dip = np.degrees(np.arctan2(np.hypot(nx,ny), nz))
        # strike dir
        dipdir = np.degrees(np.arctan2(nx, ny)) % 360.0
        strike = (dipdir - 90.0) % 360.0
        strikes.append(strike)
        dips.append(dip)
    return np.array(strikes), np.array(dips)

def plot_and_save(strikes, dips, plot_limit, method, sigma, out, return_fig=False):
    # do not use input(); use method/sigma/out passed in
    fig, (ax1,ax2) = plt.subplots(2,1, subplot_kw={'projection':'stereonet'})
    # top: poles + planes
    ax1.pole(strike_sub, dip_sub, '.', ms=2, alpha=0.8)
    #ax1.plane(strike_sub, dip_sub, linewidth=0.5, alpha=0.4)
    ax1.grid(True)
    # bottom: density contour
    dens = ax2.density_contourf(
        strike, dip,
        measurement='poles',
        #gridsize=[36,18],        # unchanged default resolution
        method=method,
        sigma=sigma
    )
    if out:
        plt.savefig(out, dpi=300)
        print(f"→ Saved figure to {out}")
    plt.show()
    if return_fig:
        return fig
    else:
        plt.show()

# 2) UI widgets
st.title("Structural Trend Calculator")
uploaded = st.file_uploader("Upload CSV", type="csv")
header_skip = st.number_input("Skip header rows", 0, 100, 0)
sep_limit    = st.number_input("Separation limit", 0.0, 1e6, 100.0)
use_all      = st.checkbox("Use all planes?", True)
plane_range  = st.slider("Plane range", 0, 1000, (0,100))
plot_limit   = st.number_input("Max poles to plot", 1, 100000, 20000)
method       = st.selectbox("Density method", [...])
sigma        = st.number_input("Sigma", 0.1, 10.0, 1.0)
output_name  = st.text_input("Output filename (png/jpg)", "")

# 3) Run button
if st.button("Run Analysis"):
    if uploaded is None:
        st.error("Please upload a CSV.")
    else:
        df = pd.read_csv(uploaded, skiprows=header_skip)
        if df.shape[1] != 3:
            st.error("CSV must have exactly 3 columns (x,y,z).")
            st.stop()
        df.columns = ["x","y","z"]
        pts = df.values
        planes, colinear = calculate_planes(pts, sep_limit)
        st.write(f"{len(planes)} planes; {len(colinear)} colinear skipped")
        strikes, dips = extract_strike_dip(planes)
        if not use_all:
            lo,hi = plane_range
            strikes, dips = strikes[lo:hi], dips[lo:hi]
        fig = plot_and_save(strikes, dips,
                            plot_limit, method, sigma, output_name,
                            return_fig=True)
        st.pyplot(fig)
        if output_name:
            st.success(f"Image saved to {output_name}")